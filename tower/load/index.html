<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Service load measurement"><title>tower::load - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tower" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (4da69dfff 2025-10-01)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module load</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../tower/index.html">tower</a><span class="version">0.5.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module load</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#when-does-a-request-complete" title="When does a request complete?">When does a request complete?</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate tower</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">tower</a></div><h1>Module <span>load</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/tower/load/mod.rs.html#1-89">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>load</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Service load measurement</p>
<p>This module provides the <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> trait, which allows measuring how loaded a service is.
It also provides several wrapper types that measure load in different ways:</p>
<ul>
<li><a href="struct.Constant.html" title="struct tower::load::Constant"><code>Constant</code></a> — Always returns the same constant load value for a service.</li>
<li><a href="pending_requests/struct.PendingRequests.html" title="struct tower::load::pending_requests::PendingRequests"><code>PendingRequests</code></a> — Measures load by tracking the number of in-flight requests.</li>
<li><a href="peak_ewma/struct.PeakEwma.html" title="struct tower::load::peak_ewma::PeakEwma"><code>PeakEwma</code></a> — Measures load using a moving average of the peak latency for the service.</li>
</ul>
<p>In general, you will want to use one of these when using the types in <a href="../balance/index.html" title="mod tower::balance"><code>tower::balance</code></a> which
balance services depending on their load. Which load metric to use depends on your exact
use-case, but the ones above should get you quite far!</p>
<p>When the <code>discover</code> feature is enabled, wrapper types for <a href="../discover/trait.Discover.html" title="trait tower::discover::Discover"><code>Discover</code></a> that
wrap the discovered services with the given load estimator are also provided.</p>
<h2 id="when-does-a-request-complete"><a class="doc-anchor" href="#when-does-a-request-complete">§</a>When does a request complete?</h2>
<p>For many applications, the request life-cycle is relatively simple: when a service responds to
a request, that request is done, and the system can forget about it. However, for some
applications, the service may respond to the initial request while other parts of the system
are still acting on that request. In such an application, the system load must take these
requests into account as well, or risk the system underestimating its own load.</p>
<p>To support these use-cases, the load estimators in this module are parameterized by the
<a href="completion/trait.TrackCompletion.html" title="trait tower::load::completion::TrackCompletion"><code>TrackCompletion</code></a> trait, with <a href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse"><code>CompleteOnResponse</code></a> as the default type. The behavior of
<a href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse"><code>CompleteOnResponse</code></a> is what you would normally expect for a request-response cycle: when the
response is produced, the request is considered “finished”, and load goes down. This can be
overridden by your own user-defined type to track more complex request completion semantics. See
the documentation for <a href="completion/index.html" title="mod tower::load::completion"><code>completion</code></a> for more details.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tower::util::ServiceExt;
<span class="kw">use </span>tower::{load::Load, Service};
<span class="kw">async fn </span>simple_balance&lt;S1, S2, R&gt;(
    svc1: <span class="kw-2">&amp;mut </span>S1,
    svc2: <span class="kw-2">&amp;mut </span>S2,
    request: R
) -&gt; <span class="prelude-ty">Result</span>&lt;S1::Response, S1::Error&gt;
<span class="kw">where
    </span>S1: Load + Service&lt;R&gt;,
    S2: Load&lt;Metric = S1::Metric&gt; + Service&lt;R, Response = S1::Response, Error = S1::Error&gt;
{
    <span class="kw">if </span>svc1.load() &lt; svc2.load() {
        svc1.ready().<span class="kw">await</span><span class="question-mark">?</span>.call(request).<span class="kw">await
    </span>} <span class="kw">else </span>{
        svc2.ready().<span class="kw">await</span><span class="question-mark">?</span>.call(request).<span class="kw">await
    </span>}
}</code></pre></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.CompleteOnResponse"><code>pub use self::completion::<a class="struct" href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse">CompleteOnResponse</a>;</code></dt><dt id="reexport.TrackCompletion"><code>pub use self::completion::<a class="trait" href="completion/trait.TrackCompletion.html" title="trait tower::load::completion::TrackCompletion">TrackCompletion</a>;</code></dt><dt id="reexport.PeakEwma"><code>pub use self::peak_ewma::<a class="struct" href="peak_ewma/struct.PeakEwma.html" title="struct tower::load::peak_ewma::PeakEwma">PeakEwma</a>;</code></dt><dt id="reexport.PendingRequests"><code>pub use self::pending_requests::<a class="struct" href="pending_requests/struct.PendingRequests.html" title="struct tower::load::pending_requests::PendingRequests">PendingRequests</a>;</code></dt><dt id="reexport.PeakEwmaDiscover"><code>pub use self::peak_ewma::<a class="struct" href="peak_ewma/struct.PeakEwmaDiscover.html" title="struct tower::load::peak_ewma::PeakEwmaDiscover">PeakEwmaDiscover</a>;</code><wbr><span class="stab portability" title="Available on crate feature `discover` only"><code>discover</code></span></dt><dt id="reexport.PendingRequestsDiscover"><code>pub use self::pending_requests::<a class="struct" href="pending_requests/struct.PendingRequestsDiscover.html" title="struct tower::load::pending_requests::PendingRequestsDiscover">PendingRequestsDiscover</a>;</code><wbr><span class="stab portability" title="Available on crate feature `discover` only"><code>discover</code></span></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="completion/index.html" title="mod tower::load::completion">completion</a></dt><dd>Application-specific request completion semantics.</dd><dt><a class="mod" href="peak_ewma/index.html" title="mod tower::load::peak_ewma">peak_<wbr>ewma</a></dt><dd>A <code>Load</code> implementation that measures load using the PeakEWMA response latency.</dd><dt><a class="mod" href="pending_requests/index.html" title="mod tower::load::pending_requests">pending_<wbr>requests</a></dt><dd>A <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> implementation that measures load using the number of in-flight requests.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Constant.html" title="struct tower::load::Constant">Constant</a></dt><dd>Wraps a type so that it implements <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> and returns a constant load metric.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Load.html" title="trait tower::load::Load">Load</a></dt><dd>Types that implement this trait can give an estimate of how loaded they are.</dd></dl></section></div></main></body></html>